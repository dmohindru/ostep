Thus, the OS, with a little hardware support, tries its best to get out of the way of the running program, to deliver an efficient virtualization; however, by interposing at those critical points in time, the OS ensures that it maintains control over the hardware.
In virtualizing memory, we will pursue a similar strategy, attaining both efficiency and control while providing the desired virtualization.

The generic techniquewewill use,which you can consider an addition to our general approach of limited direct execution, is something that is referred to as hardware-based address translation, or just address translation for short.

15.1 Assumptions
----------------
Specifically,wewill assume for now that the user’s address spacemust be placed contiguously in physical memory. We will also assume, for simplicity, that the size of the address space is not too big; specifically, that it is less than the size of physical memory. Finally, we will also assume that each address space is exactly the same size.

15.2 An Example
---------------
128: movl 0x0(%ebx), %eax ;load 0+ebx into eax
132: addl $0x03, %eax ;add 3 to eax register
135: movl %eax, 0x0(%ebx) ;store eax back to mem

When these instructions run, from the perspective of the process, the following memory accesses take place.
• Fetch instruction at address 128
• Execute this instruction (load from address 15 KB)
• Fetch instruction at address 132
• Execute this instruction (no memory reference)
• Fetch the instruction at address 135
• Execute this instruction (store to address 15 KB)

15.3 Dynamic (Hardware-based) Relocation
----------------------------------------
Specifically, we’ll need two hardware registers within each CPU: one is called the base register, and the other the bounds (sometimes called a limit register). This base-and-bounds pair is going to allow us to place the address space anywhere we’d like in physical memory, and do so while ensuring that the process can only access its own address space.
Now, when any memory reference is generated by the process, it is translated by the processor in the following manner:

physical address = virtual address + base

Because this relocation of the address happens at runtime, and because we can move address spaces even after the process has started running, the technique is often referred to as dynamic relocation.
We should note that the base and bounds registers are hardware structures kept on the chip (one pair per CPU). Sometimes people call the part of the processor that helps with address translation the memory management unit (MMU);

15.4 Hardware Support: A Summary
--------------------------------
Hardware Requirements 								Notes
Privileged mode 									Needed to prevent user-mode processes 
													from executing privileged operations

Base/bounds registers 								Need pair of registers per CPU to support
													address translation and bounds checks

Ability to translate virtual addresses 				Circuitry to do translations and check
and check if within bounds 							limits; in this case, quite simple

Privileged instruction(s) to 						OS must be able to set these values
update base/bounds 									before letting a user program run

Privileged instruction(s) to register 				OS must be able to tell hardware what
exception handlers 									code to run if exception occurs

Ability to raise exceptions 						When processes try to access privileged
													instructions or out-of-bounds memory

15.5 Operating System Issues
----------------------------
First, the OS must take action when a process is created, finding space for its address space in memory.
When a new process is created, the OS will have to search a data
structure (often called a free list) to find room for the new address space
and then mark it used.

Second, the OS must do some work when a process is terminated (i.e.,
when it exits gracefully, or is forcefully killed because it misbehaved),
reclaiming all of its memory for use in other processes or the OS.

Third, the OSmust also performa few additional steps when a context
switch occurs. There is only one base and bounds register pair on each
CPU, after all, and their values differ for each running program, as each
program is loaded at a different physical address in memory.

We should note that when a process is stopped (i.e., not running), it is
possible for the OS to move an address space from one location in memory
to another rather easily

Fourth, the OS must provide exception handlers, or functions to be
called, as discussed above; the OS installs these handlers at boot time (via
privileged instructions).


Homework Exercises
------------------

Q1:
./relocation.py -s 1

Base-and-Bounds register information:

  Base   : 0x0000363c (decimal 13884)
  Limit  : 290

Virtual Address Trace
  VA  0: 0x0000030e (decimal:  782) --> SEGMENTATION VIOLATION
  VA  1: 0x00000105 (decimal:  261) --> VALID: 0x00003741 (dec: 14145)
  VA  2: 0x000001fb (decimal:  507) --> SEGMENTATION VIOLATION
  VA  3: 0x000001cc (decimal:  460) --> SEGMENTATION VIOLATION
  VA  4: 0x0000029b (decimal:  667) --> SEGMENTATION VIOLATION

./relocation.py -s 2
Base-and-Bounds register information:

  Base   : 0x00003ca9 (decimal 15529)
  Limit  : 500

Virtual Address Trace
  VA  0: 0x00000039 (decimal:   57) --> VALID: 0x00003CE2 (dec: 15586)
  VA  1: 0x00000056 (decimal:   86) --> VALID: 0x00003CFF (dec: 15615)
  VA  2: 0x00000357 (decimal:  855) --> SEGMENTATION VIOLATION
  VA  3: 0x000002f1 (decimal:  753) --> SEGMENTATION VIOLATION
  VA  4: 0x000002ad (decimal:  685) --> SEGMENTATION VIOLATION

./relocation.py -s 3
Base-and-Bounds register information:

  Base   : 0x000022d4 (decimal 8916)
  Limit  : 316

Virtual Address Trace
  VA  0: 0x0000017a (decimal:  378) --> SEGMENTATION VIOLATION
  VA  1: 0x0000026a (decimal:  618) --> SEGMENTATION VIOLATION
  VA  2: 0x00000280 (decimal:  640) --> SEGMENTATION VIOLATION
  VA  3: 0x00000043 (decimal:   67) --> VALID: 0x00002317 (dec: 8983)
  VA  4: 0x0000000d (decimal:   13) --> VALID: 0x000022E1 (dec: 8929)

Q2:
./relocation.py -s 0 -n 10
Set limit register to max virtual address generated plus 
ARG seed 0
ARG address space size 1k
ARG phys mem size 16k

Base-and-Bounds register information:

  Base   : 0x0000360b (decimal 13835)
  Limit  : 930

Virtual Address Trace
  VA  0: 0x00000308 (decimal:  776) --> VALID: 0x00003913 (decimal: 14611)
  VA  1: 0x000001ae (decimal:  430) --> VALID: 0x000037b9 (decimal: 14265)
  VA  2: 0x00000109 (decimal:  265) --> VALID: 0x00003714 (decimal: 14100)
  VA  3: 0x0000020b (decimal:  523) --> VALID: 0x00003816 (decimal: 14358)
  VA  4: 0x0000019e (decimal:  414) --> VALID: 0x000037a9 (decimal: 14249)
  VA  5: 0x00000322 (decimal:  802) --> VALID: 0x0000392d (decimal: 14637)
  VA  6: 0x00000136 (decimal:  310) --> VALID: 0x00003741 (decimal: 14145)
  VA  7: 0x000001e8 (decimal:  488) --> VALID: 0x000037f3 (decimal: 14323)
  VA  8: 0x00000255 (decimal:  597) --> VALID: 0x00003860 (decimal: 14432)
  VA  9: 0x000003a1 (decimal:  929) --> VALID: 0x000039ac (decimal: 14764)

 For above example set limit register to 929 + 1 = 930

 Q3:
 ./relocation.py -s 1 -n 10 -l 100
 max base register = max physical memory - size of address space
 max base register = 16384 - 1024 = 0x00003C00 (dec: 15360)

 Q4:
 ./relocation.py -s 1 -n 10 -l 100 -a 2k
max base register = max physical memory - size of address space
max base register = 16384 - 2048 = 0x00003800 (dec: 14336)

./relocation.py -s 1 -n 10 -l 100 -a 4k
max base register = max physical memory - size of address space
max base register = 16384 - 4196 = 0x00002F9C (dec: 12188)

Q5:
As the limit value increases from zero to address space so is the valid random address generated.
